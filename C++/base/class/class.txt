
一：內联函数
	1：每个使用內联函数的文件必须包含其定义，通常将其放在头文件中
	2：成员函数都是内敛函数，当声明与定义分开时，需要在定义前加inline

二：成员函数
	1：调用成员函数时，不同的对象调用同一方法时，执行同一个代码快，但使用不同的数据。


三：使用类
	1：创建类对象可以声明类变量也可以用NEW分配空间
	2：iostream类的格式控制函数
		setf()
	   定点表示法：precision()
	std::streamsize prec = std::cout.precision(3);
	std::cout.precision(prec);
	std::ios_base::fmtflag orig = std::cout.setf(std::ios_base::fixed);
	std::cout.setf(orig,std::ios_base::floatfield);

四：初始化
	1：既可以使用初始化也可以通过赋值来设置对象时，应采用初始化方式效率更高
	2:列表初始化
	Stack hot_tip = {"jj",100,45.0};
	Stack hot_tip  {"jj",100,45.0};
	Stack hot_tip = {};

	2:const成员函数----不该修改类
	voi show() conat;

	3：this指针
		每个成员函数都有一个this指针。当成员函数为const成员函数时，将this限定为const this，不能使用this修改对象的值

	4:初始化列表
	const成员、被声明为引用的成员必须使用初始化列表初始化。

五：使用类
	
	1：不要返回指向局部变量或临时对象的引用。函数执行完后，局部变量和临时对象将消失，引用将指向不存在的数据
	2：如果要为类重载运算符，并非将类的项作为其第一个参数，可以使用友元函数将其反转

	3:类的类型转换
		1）只接受一个参数的构造函数定义了从参数类型到类类型的转换。若使用关键字explicit限定类构造函数，则它只能用于显示转换。构造函数只用于从某种类型到类类型的转换

		如：Stonewt incognito = 275;//使用构造函数初始化，类型转换Stonewt incognito(275);
		Stonewt incohnito = Stonewt(75);

		2)转换函数
		（explicit		）operator typename();
		转换函数必须是类方法
		不能指定返回类型
		不能有参数
		必须返回转换后的值

		
		注：（1）int转换将待转换的值四舍五入为最接近的整数
			（2）较早的get(char *,int)读取空行后，返回值不为false.若读取类空行，则第一个字符为空字符；
		if(!cin || temp[0]=='\0')
			break;


		3)加法定义为友元可以让程序更容易适应自动类型转换
		4)运算符函数
			成员函数时，第一个参数将是调用函数的对象

		4：静态类成员
			1）无论创建多少个对象，程序都只创建一个静态成员副本，类的所有对象共享一个静态成员			
			2）不能在类声明中初始化静态成员变量，初始化时不是用static。若静态成员是整形或const枚举型，可以在类声明中初始化

		5：c++11空指针：nullptr

		6:静态成员函数
			1）单独定义时，不能有static
			2)不能由对象调用，不能使用this指针。在公有部分声明时，可使用类名调用
			3）只能使用静态成员

		7:返回对象
		1）const对象的引用：参数为const引用
		2）非const引用
			重载赋值运算符以及重载与cout一起使用
		3）局部变量返回时，返回对象



六：编程技术
	1:重载<<运算符
	ostream& operator<<(ostream& os,const c_name& obj)
{
	os << ..';
	return os;
}
	
	2:转换函数
	1）单个值转换为类类型：c_name(type_name value)
	2)类转换为其他类型：operator typename()

	3:构造函数使用类
	c_name& c_name::operator=(const c_name& cn)
{
	if(this == &cn)
		return *this;
	delete [] c_pointer;
	c_pointer = new type_name[size];

	return *this;
}

	4：队列模拟
	1）使用new的类通常需要包含显示赋值构造函数和显示赋值运算符
	伪私有成员方法：不可被访问，不允许被赋值
	class Queue{
		private:
			Queue(const &q):qsize(0){}
			Queue& operator=(const Queue& q){ return *this; }
	};



七：继承
	一）public继承
	1：public继承
		注意：1）派生类需要自己的个构造函数（构造函数必须给新成员和继承的成员提供数据），可以添加其他的数据成员和函数
			2)派生类不能直接访问基类的私有成员
			3）创建派生类对象前先创建基类对象，若不调用基类构造函数，则调用默认的。通过初始化列表调用基类构造函数
			4）派生类对象可以使用基类的非私有方法，基类指针与引用可以指向或引用派生类对象，反之不行

	2：多态公有继承
		1）使用虚方法
		2）在派生类中重新定义基类方法
		3）使用关键字virtual，程序根据引用类型或指针类型选择方法，否则根据引用或指针指向对象类型选择方法
	
	3:浮点值的定点设置
		即将浮点值设置为两位小数
	(1)使用函数调用
	typedef ios_bse::fmtflags format;
	typedef streamsize precis;
	format setFormat();
	void restore(format f,precis p);
	format setFot()
	{
		return cout.setf(ios_bse::fixed,ios_base::floatfield);
	}
	void restore(format f,precis p)
	{
		cout.setf(f,ios_base::floatfield);
		cout.precision(p);
	}

	（2）使用结构体
		struct Formatting
		{
			std::ios_base::fmtflags flag;
			std::streamsize pr;
		};
		Formatting f = SetFormat();
		Restore(f);
	4：虚函数
	（1）:指针与引用类型的兼容性
	1）向上强制转换，可进行隐式转换
		派生类引用或指针可转换为基类指针与引用。按值传递只会导致将派生类的基类部分传给函数，只会调用基类函数。而指针与引用将会调用派生类的方法
	2）当函数为虚函数时，将以指针指向类型为准。否则以指针为准


	（2）：若要在派生类中重新定义基类方法，则将其设置为虚方法（动态联编）。否则为非虚方法（静态联编）。
	静态联编效率更高但不具备动态联编功能。


	（3）虚函数在基类中重新定义将会隐藏原来的函数。因此重新定义继承方法时应该与原来的类型保持一致

	（4）若基类声明被重载，则应该在派生类中重新定义所有的基类版本，否则没有定义的版本会被隐藏，派生类对象将无法使用。




	二）protected
		注：在类外只能使用公有成员来访问protected中的成员。派生类的成员可以直接访问基类的保护成员，不能直接访问基类的私有成员

	1:最好对类数据成员采用私有访问控制，不要使用保护访问控制。同时通过基类方法使派生类能够访问基类数据。
	2：对于成员函数，保护访问控制很有用，让派生类能够访问公众不能使用的内部成员


	三）抽象基类
	列：
		从椭圆和园类中抽象出他们的共性，将这些特性放入一个ABC类后从该ABC派生出Ellipse和Circle类。这样可以使用基类指针数组同时管理两个类对象。
	c++通过使用纯虚函数提供未实现的函数，纯虚函数声明的结尾处为=0.包含纯虚函数的类只能做基类。

	四）继承与动态内存分配
	1：派生类不使用new
	不包含其他一些不常用的、需要特殊处理的涉及。不需要显示定义析构函数 构造函数 赋值构造函数 赋值运算符

	2：派生类使用new
	需要定义显示析构 复制构造函数 赋值运算符
	1）派生类显示析构函数自动调用基类的析构函数，故其自身的职责是对派生类构造函数执行的清理工作
	2）复制构造函数
	派生类复制构造函数只能访问派生类数据。因此必须调用基类复制构造函数处理共享的基类数据。
	3）赋值运算符
	派生类的赋值运算符必须负责所有继承的数据的赋值，可以通过显示调用基类赋值运算符


	五)基类与派生类
	1:派生类可以调用基类的函数，处理基类的数据，再单独处理新增的数据与行为。
	2：（复制）构造函数的动态数据成员赋值前不许要delete.但赋值运算符需要


 八 ： 代码重用
 	1:包含对象成员的类
	实例：Student类
	1）被包含对象的接口不是公有的，但可以在类方法中使用

	2：私有继承
	1）私有继承将对象作为一个未命名的继承对象添加到类中。特性与包含相同：获得实现，不获得接口。
	（1）初始化基类组件
	使用类名标识构造函数和
	（2）使用基类方法
	使用类名和作用域解析运算符调用基类方法。
	（3）访问基类对象
	使用强制类型转换：（const string&） *this;
	(4)访问基类友元函数
	显示地转换为基类来正确调用函数；
	ostream& operator<<(ostream& os,const Student& stu)
	{
		os << "Scores:" << (const string&)stu ;
	}

	3:如何选择
	应使用包含建立has-a关系。若新类需要访问基类的保护成员，或需要重新定义虚函数，则应使用私有继承。

	3：多重继承
