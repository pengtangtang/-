
1)cube(double x)--返回double的立方

一：函数指针
	1:声明
		可以首先编写函数原型，然后(*pf)替换函数名
	2：函数的特征标和返回类型必须与pf相同，才允许赋值
	3：pf (*pf)可以向使用函数名一样使用
	4:动态类型推断功能：auto
	5:可以使用typedef放在函数指针声明前，为函数取别名

二：递归
	1：包含一个递归调用的递归
		通常的方法是将递归调用放在if中
	2：包含多个递归调用的递归，当递归层次少可用

三：函数与string对象/
	string数组可像使用array对象数组普通数组一样


四：函数与结构
	1：与数组不同：结构名只表示结构的名称，结构的地址需要使用&与数组
	2：引用传递来代替赋值传递，会提高运行速度
	3：atan2()计算两边的角度
	  包含《cmath》头文件
	  编译时：加-lm
	4:cin在循环输入结束后还需重新输入，必须用cin.clear（）重置输入

五：內联函数
	1：在声明或定义之前使用inline
	2:宏只是通过文本替换来实现，应使用内联代替

六：引用变量
	1：主要用于函数参数，与指针类似，引用传递
	2：声明时必须初始化，和const类似，初始化后不能再赋值
	3:如果函数调用的参数不是左值或与相应的const引用参数的类型不匹配，则c++将创建类型正确的匿名变量，将函数调用的参数的值传递给该匿名变量，并让参数引用该变量，且传递给函数的参数值不变
	4：最好使用const引用型参
	5：&name--左值引用
	   &&name---右值引用
	6：将引用用于结构和类
	7：避免返回一个指向临时变量的引用与指针，最好返回一个函数参数的引用或使用new来分配新的存储空间
	8：为何使用const用于引用返回类型
		想要使用引用返回值但不允许修改

	setf(ios_base::showpoint)--设置为小数模式

七：函数参数使用原则
    一)传递值而不修改的函数
	1：数据对象很小--内置数据类型或小型数据，按值传递
	2：数据对象是数组---使用指针
	3：较大的结构---const 指针或const引用
	4：类对象---必须是const引用

八：默认参数
	必须通过函数原型，且从到左设置

九：函数重载
	1：非const值可以赋值给const值，反之不行
	2：仅当函数基本上执行相同的任务，但使用不同形式的数据

十：函数模板
	1：若需要多个将同一种算法用于不同类型的函数，就请使用模板

十一：重载模板
	像重载函数一样重载模板
	template<typename T>
	void Swap(T& a,T&b);

	template<typename T>
	void Swap(T* a,T* b,int n);



十二：函数模板的
	
1）显示具体化
	template<> void Swap<job>(job &,job &);
1:给定的函数名，可以有非模板/模板/显示具体化模板函数及其重载函数
2：以template<>打头，且通过名称指出类型
3：常规 》 具体化 》 模板
	void Swap(job &,job&);

	template <typename T>
	void Swap(T &,T&)

	template<> void Swap(job &,job &)；

2）显示实例化
	
	template void Swap(job &,job &)；
注意：
	(1)试图在同一个文件中使用显示具体化与显示实例化 将出错
	(2)decltype关键字
		当使用变量不知到是什么类型时，使用decltype(expression) var;
		1::expression是标识符，则var的类型与标识符类型相同
		2::expression是函数调用，则var的类型与函数妇返回类型相同
		3::expression是用括号括起的标识符，则var为指向其类型的引用
		4::其他情况，var与expression类型相同
		若k和n都是引用，但k+n不是引用

	（3）decltype解决不了的情况
	type gt(T1 x,T2 y)
	{return x+y;}
	使用后置返回类型：auto gt(T1 x,T2 y) -> decltype(x+y)
{
	return x+y;
}
